
Greedy Algorithm 最核心的價值就是每一步都選擇當前狀況下最優的選擇，期望能夠得到全局最優解，這種算法不考慮未來的後果，只專注於當前的局部最優解。

他有幾個特點：
1. 局部最優選擇： 在每一步選擇中，總是做出當前看起來最好的選擇（最小化或最大化某個值）。
2. 無法 Backtrack： 一旦做出選擇，就不會撤回或改變這個選擇。
3. 無全局視角： 只關注當前的選擇，不會管未來會發生甚麼事。

Greedy 最難的不在於問題的解，而在於是正確性的證明，但是在日常寫題或是演算法面試中，不太會要求大家證明貪心演算法的正確性。所以，當我們想要判斷一個問題是否透過貪心演算法求解時，我們可以：

1. 憑直覺：如果感覺這題可以透過 Greedy 去做，就可以嘗試找出每一步的「局部最優選擇」，再思考這樣的策略是否能推出整體的最優解（全局最優）。
2. 舉反例：嘗試一下，舉出反例。試著舉出反例來驗證。也就是觀察是否存在某些情況，局部最優選擇反而導致了整體結果變差。如果能舉出反例，代表這題不能用 Greedy；反之，如果怎麼試都舉不出反例，那這題大概率就是可以用貪心解的。

簡單來說：

> 當我們確定每個子問題的最佳解都可以安全地合併為全局最優解時，Greedy 就成立。

舉 [ Leetcode 455 ] Assign Cookies 為例，題目如下：

> 題目要求我們用餅乾來滿足孩子的需求。給兩個 array：
> 
> `g`：表示每個孩子的胃口大小，數字越大代表胃口越大。
> `s`：表示每塊餅乾的大小，數字越大代表餅乾越大。
> 
> 我們的目標是將餅乾分配給孩子，並盡可能使最多的孩子得到他們需要的餅乾。每個孩子只能獲得一塊餅乾，且餅乾的大小必須大於等於孩子的胃口才能滿足該孩子，我們要回傳最多可以滿足的孩子數量。

所以「局部最優解」就是對於每一個餅乾來說，從最小的開始分配給目前胃口最小的小孩，如果目前最小的餅乾連目前胃口最小的小孩都沒辦法滿足，那這片餅乾也沒有用了要換下一片，如果這片餅乾可以滿足這個小孩，就分配給他然後往下看換下一片餅乾跟下一個小孩。

再來我們要嘗試舉反例，假設我們把比較大的餅乾（如大小 3）先給了胃口只有 1 的小孩，之後如果遇到胃口是 3 的小孩而只剩下餅乾大小 2，就無法滿足了。這種情況就是「非最優選擇導致更壞結果」的例子，因為我們總是優先讓「小胃口小孩」先用「小餅乾」，才能騰出大餅乾給胃口大的人，這樣子的 Greedy 沒有反例，所以表示 Greedy 是正確的。

再來舉一個看起來像 Greedy 實際上要用 DP 解的例子，[ Leetcode 53 ] Maximum Subarray 説：

> 給一個整數 array，找出一個連續 subarray，使其總和最大。

表面上看起來很像 Greedy，只要「從左到右一直加正數，看到負數就丟掉」就好，但實際上我們是可以舉出反例的：

> nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
> Greedy 加到 -3 就會斷掉，但實際最大子陣列是 [4, -1, 2, 1] = 6。

所以這題要用 DP 來解。

### 範例

455
55